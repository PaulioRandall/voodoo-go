package scanner

import (
	"github.com/PaulioRandall/voodoo-go/fault"
	"github.com/PaulioRandall/voodoo-go/runer"
	"github.com/PaulioRandall/voodoo-go/symbol"
)

// Scan scans a line and creates an array of lexemes based on
// the grammer rules of the language. Longest match is used to
// identify variable names and keywords etc.
//
// No panic is generated by the scanner so if a panic occurs it's
// either a system issue or a bug.
func Scan(in string) (out []symbol.Lexeme, err fault.Fault) {

	if in == `` {
		out = []symbol.Lexeme{}
		return
	}

	itr := runer.NewRuneItr(in)

	for itr.HasNext() {
		var l *symbol.Lexeme

		switch {
		case itr.IsNextLetter():
			l = scanWord(itr)
		case itr.IsNextDigit():
			l, err = scanNumber(itr)
		case itr.IsNextSpace():
			l = scanSpace(itr)
		case itr.IsNext('@'):
			l, err = scanSpell(itr)
		case itr.IsNext('"'):
			l, err = scanString(itr)
		case itr.IsNextStr(`//`):
			l = commentLex(itr)
		default:
			l, err = symbolLex(itr)
		}

		if err != nil {
			out = nil
			break
		}

		out = append(out, *l)
	}

	return
}

// commentLex handles lexemes that start with two forward slashes
// `//`. Double forward slashes may resolve into a:
// - comment
func commentLex(itr *runer.RuneItr) *symbol.Lexeme {

	start := itr.Index()
	str := itr.RemainingStr()

	return &symbol.Lexeme{
		Val:   str,
		Start: start,
		End:   itr.Index(),
		Type:  symbol.COMMENT,
	}
}

// symbolLex handles any lexemes that are symbols. These
// symbols may resolve into a:
// - operator, 1 or 2 runes including truthy and not
// - code block start or end, i.e. bracket
// - value separator, i.e. comma
// - key-value separator, i.e. colon
// - void value, i.e. underscore
// - range generator
func symbolLex(itr *runer.RuneItr) (l *symbol.Lexeme, err fault.Fault) {

	start := itr.Index()
	var t symbol.SymbolType
	c := 0

	set := func(lexType symbol.SymbolType, runeCount int) {
		t = lexType
		c = runeCount
	}

	switch {
	case itr.IsNextStr(`<-`):
		set(symbol.ASSIGNMENT, 2)
	case itr.IsNextStr(`<=`):
		set(symbol.CMP_LESS_THAN_OR_EQUAL, 2)
	case itr.IsNext('<'):
		set(symbol.CMP_LESS_THAN, 1)
	case itr.IsNextStr(`>=`):
		set(symbol.CMP_GREATER_THAN_OR_EQUAL, 2)
	case itr.IsNext('>'):
		set(symbol.CMP_GREATER_THAN, 1)
	case itr.IsNextStr(`==`):
		set(symbol.CMP_EQUAL, 2)
	case itr.IsNextStr(`!=`):
		set(symbol.CMP_NOT_EQUAL, 2)
	case itr.IsNextStr(`=>`):
		set(symbol.LOGICAL_MATCH, 2)
	case itr.IsNext('!'):
		set(symbol.LOGICAL_NOT, 1)
	case itr.IsNextStr(`||`):
		set(symbol.LOGICAL_OR, 2)
	case itr.IsNextStr(`&&`):
		set(symbol.LOGICAL_AND, 2)
	case itr.IsNext('+'):
		set(symbol.CALC_ADD, 1)
	case itr.IsNext('-'):
		set(symbol.CALC_SUBTRACT, 1)
	case itr.IsNext('*'):
		set(symbol.CALC_MULTIPLY, 1)
	case itr.IsNext('/'):
		set(symbol.CALC_DIVIDE, 1)
	case itr.IsNext('%'):
		set(symbol.CALC_MODULO, 1)
	case itr.IsNext('('):
		set(symbol.PAREN_CURVY_OPEN, 1)
	case itr.IsNext(')'):
		set(symbol.PAREN_CURVY_CLOSE, 1)
	case itr.IsNext('['):
		set(symbol.PAREN_SQUARE_OPEN, 1)
	case itr.IsNext(']'):
		set(symbol.PAREN_SQUARE_CLOSE, 1)
	case itr.IsNext(','):
		set(symbol.SEPARATOR_VALUE, 1)
	case itr.IsNext(':'):
		set(symbol.SEPARATOR_KEY_VALUE, 1)
	case itr.IsNextStr(`..`):
		set(symbol.RANGE, 2)
	case itr.IsNext('_'):
		set(symbol.VOID, 1)
	default:
		ru := itr.NextRune()
		m := "I don't know what this symbol means '" + string(ru) + "'"
		err = fault.Sym(m).From(start).To(itr.Index())
		return
	}

	s, e := itr.NextStr(c)
	if e != nil {
		err = fault.Sym(err.Error()).From(start).To(itr.Index())
		return
	}

	l = &symbol.Lexeme{
		Val:   s,
		Start: start,
		End:   itr.Index(),
		Type:  t,
	}

	return
}

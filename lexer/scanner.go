package lexer

import (
	"strings"

	"github.com/PaulioRandall/voodoo-go/fault"
	"github.com/PaulioRandall/voodoo-go/runer"
	"github.com/PaulioRandall/voodoo-go/symbol"
)

// ScanLine scans a line and creates an array of lexemes based on
// the grammer rules of the language. If the line is empty then an
// empty array will be returned. If the line contains whitespace
// only a single symbol with the whitespace type is returned.
// Longest match is used to identify variable names and keywords
// etc.
//
// No panic is generated by the scanner so if a panic occurs it's
// either a system issue or a bug.
func ScanLine(line string, lineNum int) (ls []symbol.Lexeme, err fault.Fault) {

	if line == `` {
		ls = []symbol.Lexeme{}
		return
	}

	itr := runer.NewRuneItr(line)

	for itr.HasNext() {
		var l *symbol.Lexeme

		switch {
		case itr.IsNextLetter():
			l = wordLex(itr)
		case itr.IsNextDigit():
			l, err = numLex(itr)
		case itr.IsNextSpace():
			l = spaceLex(itr)
		case itr.IsNext('@'):
			l, err = sourceryLex(itr)
		case itr.IsNext('"'):
			l, err = strLex(itr)
		case itr.IsNextStr(`//`):
			l = commentLex(itr)
		default:
			l, err = symbolLex(itr)
		}

		if err != nil {
			err = err.Line(lineNum)
			ls = nil
			break
		}

		l.Line = lineNum
		ls = append(ls, *l)
	}

	return
}

// wordLex handles lexemes that start with a unicode category L rune.
// I.e. a letter from any alphabet, a word may resolve into a:
// - variable name
// - keyword
// - boolean value (`true` or `false`)
func wordLex(itr *runer.RuneItr) *symbol.Lexeme {

	start := itr.Index()
	s := extractWordStr(itr)
	t := symbol.UNDEFINED

	switch strings.ToLower(s) {
	case `spell`:
		t = symbol.KEYWORD_SPELL
	case `loop`:
		t = symbol.KEYWORD_LOOP
	case `when`:
		t = symbol.KEYWORD_WHEN
	case `end`:
		t = symbol.KEYWORD_END
	case `key`:
		t = symbol.KEYWORD_KEY
	case `val`:
		t = symbol.KEYWORD_VAL
	case `true`:
		t = symbol.BOOLEAN_TRUE
	case `false`:
		t = symbol.BOOLEAN_FALSE
	default:
		t = symbol.IDENTIFIER_EXPLICIT
	}

	return &symbol.Lexeme{
		Val:   s,
		Start: start,
		End:   itr.Index(),
		Type:  t,
	}
}

// numLex handles symbols that start with a unicode category Nd rune.
// I.e. any number from 0 to 9, a number may resolve into a:
// - literal number
func numLex(itr *runer.RuneItr) (l *symbol.Lexeme, err fault.Fault) {

	start := itr.Index()
	s, err := extractNum(itr)
	if err != nil {
		return
	}

	l = &symbol.Lexeme{
		Val:   s,
		Start: start,
		End:   itr.Index(),
		Type:  symbol.NUMBER,
	}

	return
}

// extractNum extracts a number, as a string, from the supplied
// iterator.
func extractNum(itr *runer.RuneItr) (string, fault.Fault) {
	sb := strings.Builder{}
	var f string
	var err fault.Fault

	for itr.HasNext() {
		if itr.IsNextStr(`..`) {
			break
		}

		if itr.IsNext('.') {
			sb.WriteRune(itr.NextRune())
			f, err = extractFrac(itr)
			sb.WriteString(f)
			break
		}

		if !itr.IsNextDigit() && !itr.IsNext('_') {
			break
		}

		sb.WriteRune(itr.NextRune())
	}

	return sb.String(), err
}

// extractFrac extracts the fractional part of a number,
// as a string, from the supplied iterator and returns it.
func extractFrac(itr *runer.RuneItr) (string, fault.Fault) {
	sb := strings.Builder{}

	for itr.HasNext() {
		if itr.IsNext('.') {
			m := "Numbers can't have two fractional parts"
			return "", fault.Num(m).From(itr.Index())
		}

		if !itr.IsNextDigit() && !itr.IsNext('_') {
			break
		}

		sb.WriteRune(itr.NextRune())
	}

	return sb.String(), nil
}

// spaceLex handles lexemes that start with a rune with the
// unicode whitespace property.
// I.e. any whitespace rune, whitespace may resolve into a:
// - maningless lexeme that can be ignored at the parsing stage
func spaceLex(itr *runer.RuneItr) *symbol.Lexeme {

	start := itr.Index()
	sb := strings.Builder{}

	for itr.HasNext() {
		if !itr.IsNextSpace() {
			break
		}
		sb.WriteRune(itr.NextRune())
	}

	return &symbol.Lexeme{
		Val:   sb.String(),
		Start: start,
		End:   itr.Index(),
		Type:  symbol.WHITESPACE,
	}
}

// sourceryLex handles lexemes that start with a at sign rune `@`.
// Sourcery symbol may resolve into a:
// - go function call
func sourceryLex(itr *runer.RuneItr) (s *symbol.Lexeme, err fault.Fault) {

	if !itr.IsRelLetter(1) {
		m := "Expected first rune after `@` to be a letter"
		err = fault.Func(m).From(itr.Index())
		return
	}

	start := itr.Index()
	h := string(itr.NextRune())
	t := extractWordStr(itr)

	s = &symbol.Lexeme{
		Val:   h + t,
		Start: start,
		End:   itr.Index(),
		Type:  symbol.SOURCERY,
	}

	return
}

// strLex handles lexemes that start with the double quote `"` rune.
// Quoted strings may resolve into a:
// - string literal
func strLex(itr *runer.RuneItr) (l *symbol.Lexeme, err fault.Fault) {

	start := itr.Index()
	closed, s := extractStr(itr)

	if !closed {
		m := "Did someone forget to close a string literal?!"
		err = fault.Str(m).From(start).To(itr.Index())
		return
	}

	l = &symbol.Lexeme{
		Val:   s,
		Start: start,
		End:   itr.Index(),
		Type:  symbol.STRING,
	}

	return
}

// extractStr extracts a string literal from a string iterator
// returning true if the last rune was escaped.
func extractStr(itr *runer.RuneItr) (closed bool, s string) {

	sb := strings.Builder{}
	sb.WriteRune(itr.NextRune())
	isEscaped := false

	for itr.HasNext() {
		ru := itr.NextRune()
		sb.WriteRune(ru)

		if !isEscaped && ru == '"' {
			closed = true
			break
		}

		if ru == '\\' {
			isEscaped = !isEscaped
		} else {
			isEscaped = false
		}
	}

	s = sb.String()
	return
}

// commentLex handles lexemes that start with two forward slashes
// `//`. Double forward slashes may resolve into a:
// - comment
func commentLex(itr *runer.RuneItr) *symbol.Lexeme {

	start := itr.Index()
	str := itr.RemainingStr()

	return &symbol.Lexeme{
		Val:   str,
		Start: start,
		End:   itr.Index(),
		Type:  symbol.COMMENT,
	}
}

// symbolLex handles any lexemes that are symbols. These
// symbols may resolve into a:
// - operator, 1 or 2 runes including truthy and not
// - code block start or end, i.e. bracket
// - value separator, i.e. comma
// - key-value separator, i.e. colon
// - void value, i.e. underscore
// - range generator
func symbolLex(itr *runer.RuneItr) (l *symbol.Lexeme, err fault.Fault) {

	start := itr.Index()
	var t symbol.SymbolType
	c := 0

	set := func(lexType symbol.SymbolType, runeCount int) {
		t = lexType
		c = runeCount
	}

	switch {
	case itr.IsNextStr(`<-`):
		set(symbol.ASSIGNMENT, 2)
	case itr.IsNextStr(`<=`):
		set(symbol.LESS_THAN_OR_EQUAL, 2)
	case itr.IsNext('<'):
		set(symbol.LESS_THAN, 1)
	case itr.IsNextStr(`>=`):
		set(symbol.GREATER_THAN_OR_EQUAL, 2)
	case itr.IsNext('>'):
		set(symbol.GREATER_THAN, 1)
	case itr.IsNextStr(`==`):
		set(symbol.EQUAL, 2)
	case itr.IsNextStr(`=>`):
		set(symbol.IF_MATCH_THEN, 2)
	case itr.IsNextStr(`!=`):
		set(symbol.NOT_EQUAL, 2)
	case itr.IsNext('!'):
		set(symbol.NEGATION, 1)
	case itr.IsNextStr(`||`):
		set(symbol.OR, 2)
	case itr.IsNextStr(`&&`):
		set(symbol.AND, 2)
	case itr.IsNext('+'):
		set(symbol.ADD, 1)
	case itr.IsNext('-'):
		set(symbol.SUBTRACT, 1)
	case itr.IsNext('*'):
		set(symbol.MULTIPLY, 1)
	case itr.IsNext('/'):
		set(symbol.DIVIDE, 1)
	case itr.IsNext('%'):
		set(symbol.MODULO, 1)
	case itr.IsNext('('):
		set(symbol.CURVED_BRACE_OPEN, 1)
	case itr.IsNext(')'):
		set(symbol.CURVED_BRACE_CLOSE, 1)
	case itr.IsNext('['):
		set(symbol.SQUARE_BRACE_OPEN, 1)
	case itr.IsNext(']'):
		set(symbol.SQUARE_BRACE_CLOSE, 1)
	case itr.IsNext(','):
		set(symbol.VALUE_SEPARATOR, 1)
	case itr.IsNext(':'):
		set(symbol.KEY_VALUE_SEPARATOR, 1)
	case itr.IsNextStr(`..`):
		set(symbol.RANGE, 2)
	case itr.IsNext('_'):
		set(symbol.VOID, 1)
	default:
		ru := itr.NextRune()
		m := "I don't know what this symbol means '" + string(ru) + "'"
		err = fault.Sym(m).From(start).To(itr.Index())
		return
	}

	s, e := itr.NextStr(c)
	if e != nil {
		err = fault.Sym(err.Error()).From(start).To(itr.Index())
		return
	}

	l = &symbol.Lexeme{
		Val:   s,
		Start: start,
		End:   itr.Index(),
		Type:  t,
	}

	return
}

// extractWordStr iterates a rune iterator until a single word has
// been extracted retruning the string.
func extractWordStr(itr *runer.RuneItr) string {
	sb := strings.Builder{}

	for itr.HasNext() {
		switch {
		case itr.IsNextLetter():
			fallthrough
		case itr.IsNextDigit():
			fallthrough
		case itr.IsNext('_'):
			sb.WriteRune(itr.NextRune())
		default:
			return sb.String()
		}
	}

	return sb.String()
}
